# xv6
Implementation of various extra functionalities in the xv6 operating system to improve efficiency. Below is a short summary of the implemented changes. There is a test file added in every folder to ensure the right behavior. 

- File systems: xv6 does not support basic access permissions like most Unix-like systems. We will implement this functionality by defining a variable `uint mode` (bit 0 represents the readability of the file, bit 1 the writability and bit 2 the executability) and adding it to the different representations of files in xv6 and the file metadata (`struct dinode`, `struct inode` and `struct stat`). Numerous functions in [fs.c](https://github.com/Ferrevdv/OS-labs/blob/main/file_systems/kernel/fs.c) are adjusted accordingly and `ls` now shows the permissions of files (in a 'rwx' format). The new system call `int chmod(const char*, int)` takes a path to a file as the first parameter and changes its permissions to the second parameter. We also added a new user space program `chmod` so the user can manually change permissions (e.g. `chmod 7 README`). `exec` and the `open` syscall are adjusted so that the access permissions are enforced.

- Locks: the original `kalloc` function in xv6 causes high lock contention due to the use of only one free list of processors. We will reduce this lock contention by giving each processor its own free list and the possibility to steal free frames from other processors (`kmem` is replaced by an array of `NCPU` `kmem` variables in [kalloc.c](https://github.com/Ferrevdv/OS-labs/blob/main/locks/kernel/kalloc.c)). An important parameter for this implementation is the number of frames that gets stolen at once. With extensive testing we found that `NFRAMES = 8` yields optimal results. During the initialization of `kalloc` all frames will be assigned to CPU 0, since `kinit` is called by [main](https://github.com/Ferrevdv/OS-labs/blob/main/locks/kernel/main.c) on this CPU.

- System calls: we added a new system call `void traceme(int enable)` that (if `enable` is truthy) will print every system call of the process to the console, together with the `pid` of the process. The new user-space program `trace` calls the executable argument it receives with the `traceme`functionality enabled. 

- Traps: the `malloc` implementation of xv6 allocates more memory than asked for to reduce the amount of syscalls. We shall now implement demand paging to prevent overuse of heap memory by making `sbrk` lazy. The newly added function `void pagefault(uint64 va)` in [vm.c](https://github.com/Ferrevdv/OS-labs/blob/main/traps/kernel/vm.c) takes the virtual address that was called when the page fault occurred as an argument and serves as a page fault handler. We use `kalloc` to allocate new physical frames and make the mappings via `mappages` (using the [struct proc::sz](https://github.com/Ferrevdv/OS-labs/blob/main/traps/kernel/proc.h) variable to ensure that this is only done for addresses that were previously allocated via `sbrk`). Several functions in xv6 need to be adjusted since the invariant that all pages between `[0, struct proc::sz)` must be mapped no longer holds true for demand paging. 

- Virtual memory: the `uptime` syscall in xv6 simply returns the global variable `ticks`. It is particular inefficient to perform two context switches (syscall) only for the sake of reading such a variable. We will optimize this by implementing a similar mechanism as the vDSO mechanism (used in the Linux kernel) to be able to fully execute certain syscalls in the user space. We generate a linker section `.vdso` with only `ticks` in it and adjust the linker script. The page with the `.vdso` section is mapped at the same location in every user process by adjusting the [proc_pagetable](https://github.com/Ferrevdv/OS-labs/blob/main/virtual_memory/kernel/proc.c) function. Lastly a user space function `fastuptime` is created to read the `ticks` variable in the mapped page and return it. 
